from flask import Flask, request, jsonify
import os
import json
import time
from datetime import date
from threading import Lock
import requests

app = Flask(__name__)

# â”€â”€â”€ CONSTANTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
TANK_DEPTH_CM   = 38.0
V_EMPTY         = 0.0
V_FULL          = 2.98882
VOLTAGE_MAX     = 3.2
FILTER_ALPHA    = 0.07

TANK4_DEPTH_IN  = 37.5
ULTRA_FILTER_ALPHA = 0.2

LOG_DIR = "logs"
MAX_LOG_DAYS = 7
os.makedirs(LOG_DIR, exist_ok=True)

# Alarm state tracking to allow only one alert per fill cycle
alarm_already_fired_this_cycle = False

# â”€â”€â”€ ALARM CONFIGURATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ALARM_PI_IP = "192.168.0.118"          
ALARM_ENDPOINT = f"http://{ALARM_PI_IP}:6000/alarm"
ALARM_LOW_THRESHOLD_IN = 32.4          # trigger when remaining depth â‰¤ this
ALARM_HIGH_THRESHOLD_IN = 34.5         # do not trigger again until depth > this
ALARM_COOLDOWN_SECONDS = 7200         

last_alarm_time = 0.0

# â”€â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
stats_lock = Lock()
file_lock  = Lock()

smoothed_voltage = None
ultra_smoothed = None

stats = {
    "min_v": None, "max_v": None,
    "min_depth": None, "max_depth": None,
    "min_pct": None, "max_pct": None,
    "min_up": None, "max_up": None
}

# â”€â”€â”€ HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def today_filename():
    return os.path.join(LOG_DIR, date.today().isoformat() + ".json")

def cleanup_old_logs():
    with file_lock:
        files = sorted(f for f in os.listdir(LOG_DIR) if f.endswith(".json"))
        while len(files) > MAX_LOG_DAYS:
            try:
                os.remove(os.path.join(LOG_DIR, files.pop(0)))
            except:
                pass

def safe_filter_voltage(raw):
    global smoothed_voltage
    try:
        clamped = max(0.0, min(float(raw), VOLTAGE_MAX))
    except:
        clamped = 0.0
    if smoothed_voltage is None:
        smoothed_voltage = clamped
    else:
        smoothed_voltage = FILTER_ALPHA * clamped + (1 - FILTER_ALPHA) * smoothed_voltage
    return smoothed_voltage

def safe_filter_ultra(raw):
    global ultra_smoothed
    try:
        val = float(raw)
    except:
        val = 0.0
    if ultra_smoothed is None:
        ultra_smoothed = val
    else:
        ultra_smoothed = ULTRA_FILTER_ALPHA * val + (1 - ULTRA_FILTER_ALPHA) * ultra_smoothed
    return ultra_smoothed

def voltage_to_depth_pct(v):
    if V_FULL <= V_EMPTY:
        return 0.0, 0.0
    depth = (v - V_EMPTY) / (V_FULL - V_EMPTY) * TANK_DEPTH_CM
    depth = max(0.0, min(depth, TANK_DEPTH_CM))
    pct = (depth / TANK_DEPTH_CM) * 100
    return depth, pct

def update_stats(v, d, p, up):
    with stats_lock:
        def upd(key, val, mode="min"):
            if val is None: return
            if stats[key] is None:
                stats[key] = val
            elif (mode == "min" and val < stats[key]) or (mode == "max" and val > stats[key]):
                stats[key] = val
        upd("min_v", v, "min")
        upd("max_v", v, "max")
        upd("min_depth", d, "min")
        upd("max_depth", d, "max")
        upd("min_pct", p, "min")
        upd("max_pct", p, "max")
        upd("min_up", up, "min")
        upd("max_up", up, "max")

# â”€â”€â”€ API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
@app.route("/api/data", methods=["POST"])
def receive_data():
    """
    Receives sensor data (voltage and optional ultrasonic reading),
    processes it, updates statistics, logs the entry, checks for low-level alarm,
    and returns a success response.
    """
    payload = request.get_json(silent=True)
    if not payload:
        return jsonify({"error": "missing or invalid JSON payload"}), 400

    # â”€â”€â”€ 1. Extract and validate raw inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    raw_voltage = payload.get("value")
    raw_ultra   = payload.get("ultra")

    # â”€â”€â”€ 2. Apply filtering to reduce noise â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    smoothed_voltage = safe_filter_voltage(raw_voltage) if raw_voltage is not None else 0.0
    smoothed_ultra   = safe_filter_ultra(raw_ultra)     if raw_ultra   is not None else None

    # â”€â”€â”€ 3. Convert voltage â†’ tank 1 depth & percentage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    tank1_depth_cm, tank1_pct = voltage_to_depth_pct(smoothed_voltage)

    # â”€â”€â”€ 4. Convert ultrasonic â†’ tank 4 remaining depth & percentage â”€â”€â”€â”€â”€
    tank4_remaining_in = None
    tank4_pct          = None

    if smoothed_ultra is not None:
        # Ultrasonic typically measures distance from sensor to surface
        tank4_remaining_in = max(0.0, min(TANK4_DEPTH_IN - smoothed_ultra, TANK4_DEPTH_IN))
        tank4_pct = (tank4_remaining_in / TANK4_DEPTH_IN) * 100

    # â”€â”€â”€ 5. Update running statistics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    update_stats(
        v  = smoothed_voltage,
        d  = tank1_depth_cm,
        p  = tank1_pct,
        up = tank4_pct
    )

   
    # â”€â”€â”€ 6. High-water alarm logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    alarm_triggered = False

    if tank4_remaining_in is not None:
        now = time.time()
        global last_alarm_time
        global alarm_already_fired_this_cycle

        in_danger_zone = (
            ALARM_LOW_THRESHOLD_IN <= tank4_remaining_in <= ALARM_HIGH_THRESHOLD_IN
        )

        # Reset the "already fired" flag when we leave the danger zone
        # (i.e., headspace becomes > 36.0 in or < 35.0 in)
        if not in_danger_zone:
            alarm_already_fired_this_cycle = False

        # Trigger only if:
        # - Currently in the danger zone
        # - We have NOT already alerted during this high-water period
        # - Enough time has passed since the very last alarm (safety net)
        if (
            in_danger_zone
            and not alarm_already_fired_this_cycle
            and now - last_alarm_time >= ALARM_COOLDOWN_SECONDS
        ):
            try:
                response = requests.post(ALARM_ENDPOINT, timeout=4.0)
                response.raise_for_status()
                last_alarm_time = now
                alarm_already_fired_this_cycle = True
                alarm_triggered = True
                print(f"High water alarm triggered (first in cycle) â†’ remaining: {tank4_remaining_in:.2f} in")
            except requests.RequestException as exc:
                print(f"Failed to trigger alarm: {exc}")
    # Optional: log whether alarm was sent in this reading    # â”€â”€â”€ 7. Prepare log entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    entry = {
        "t":     time.time(),
        "v":     round(smoothed_voltage, 4),
        "d":     round(tank1_depth_cm, 2),
        "p":     round(tank1_pct, 1),
        "u":     round(tank4_remaining_in, 2) if tank4_remaining_in is not None else None,
        "up":    round(tank4_pct, 1)         if tank4_pct         is not None else None,
        "alarm": alarm_triggered
    }

    # â”€â”€â”€ 8. Append to today's log file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    fname = today_filename()

    with file_lock:
        data = []
        if os.path.exists(fname):
            try:
                with open(fname, "r", encoding="utf-8") as f:
                    data = json.load(f)
            except (json.JSONDecodeError, IOError):
                data = []  # corrupt file â†’ start fresh

        data.append(entry)

        try:
            with open(fname, "w", encoding="utf-8") as f:
                json.dump(data, f, separators=(",", ":"))
        except IOError as exc:
            print(f"Failed to write log file {fname}: {exc}")
            # We still return success to the device so it keeps sending data

    # â”€â”€â”€ 9. Clean up old logs (non-blocking) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    cleanup_old_logs()

    return jsonify({"status": "ok"})

@app.route("/api/current")
def get_current():
    fname = today_filename()
    entries = []
    if os.path.exists(fname):
        with open(fname, "r") as f:
            entries = json.load(f)
    return jsonify({"data": entries, "stats": stats})

@app.route("/api/history/<day>")
def get_history(day):
    path = os.path.join(LOG_DIR, f"{day}.json")
    if not os.path.exists(path):
        return jsonify([])
    with open(path, "r") as f:
        return jsonify(json.load(f))

@app.route("/api/days")
def list_days():
    days = [f[:-5] for f in os.listdir(LOG_DIR) if f.endswith(".json")]
    return jsonify(sorted(days))

# â”€â”€â”€ UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
HTML = """
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ðŸ”¥ Tr@ck33r's TANK SCADA - Cyber Edition</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<style>
/* ===== BACKGROUND GRID ===== */
#bgCanvas {
  position: fixed;
  top:0; left:0;
  z-index:0;
  width:100%;
  height:100%;
  pointer-events:none;
}

/* ===== BODY & PANELS ===== */
body {
  font-family: monospace;
  background: #010916;
  color: #0ff;
  display: flex;
  flex-wrap: wrap;
  gap:20px;
  padding:20px;
  position: relative;
}

.panel {
  flex:1 1 350px;
  min-width:300px;
  background: rgba(0,20,40,0.6);
  backdrop-filter: blur(6px);
  border-radius:16px;
  padding:20px;
  box-shadow: 0 0 20px #0ff66;
  border: 1px solid #0ff;
  position: relative;
  z-index:1;
}

/* ===== TABLES ===== */
table {
  border-collapse: separate;
  border-spacing:0;
  width:100%;
}
td { padding:8px 12px; border-bottom:1px solid rgba(0,255,255,0.2);}
td.label{opacity:0.7;}
td.value{font-weight:bold;color:#fff;}

/* ===== BUTTONS & SELECT ===== */
button, select {
  background: linear-gradient(90deg,#0ff,#4ade80);
  border:1px solid #0ff;
  color:#010916;
  font-weight:bold;
  border-radius:8px;
  box-shadow:0 0 6px #0ff;
  padding:6px 10px;
  margin-right:6px;
  cursor:pointer;
  transition: all 0.2s;
}
button:hover{box-shadow:0 0 12px #4ade80;transform:scale(1.05);}

/* ===== CHART ===== */
canvas{background: rgba(0,20,40,0.4); border-radius:12px;}

/* ===== HEADINGS ===== */
h2{text-shadow:0 0 6px #0ff; margin-bottom:12px;}

/* ===== MODE LABEL ===== */
#modeLabel{margin-top:12px;font-weight:bold;color:#0ff;text-shadow:0 0 4px #0ff;}

/* ===== WATER BARS ===== */
.tank-bar-container {
  position: relative;
  width:50px;
  height:150px;
  background: rgba(0,20,40,0.4);
  border:2px solid #0ff;
  border-radius:12px;
  margin:10px 0;
  overflow:hidden;
}
.tank-bar-fill {
  position: absolute;
  bottom:0;
  width:100%;
  height:0%;
  background: linear-gradient(to top,#60a5fa,#4ade80);
  box-shadow:0 0 10px #4ade80;
  transition: height 0.8s ease-out;
  border-radius:8px 8px 0 0;
}
#tank4-fill {
  background: linear-gradient(to top,#ff4df0,#ffaf00);
  box-shadow:0 0 10px #ff4df0;
}

/* ===== SCROLL BAR ===== */
#scroll{width:100%; margin:10px 0;}
</style>
</head>
<body>

<canvas id="bgCanvas"></canvas>

<!-- SIDE PANEL (slightly constrained width now) -->
<div class="panel" style="flex:0.1; max-width:420px;">
  <h2>ðŸ’§ PressureTransducer(T3)</h2>
  <div class="tank-bar-container"><div id="tank3-fill" class="tank-bar-fill"></div></div>
  <table>
    <tr><td class="label">Voltage</td><td class="value" id="v">--</td></tr>
    <tr><td class="label">Depth (in)</td><td class="value" id="d">--</td></tr>
    <tr><td class="label">Percent</td><td class="value" id="p">--</td></tr>
  </table>

  <h2 style="margin-top:20px;">ðŸŒŠ Ultrasonic Sensor(T2)</h2>
  <div class="tank-bar-container"><div id="tank4-fill" class="tank-bar-fill"></div></div>
  <table>
    <tr><td class="label">Depth (in)</td><td class="value" id="u">--</td></tr>
    <tr><td class="label">Percent</td><td class="value" id="up">--</td></tr>
  </table>

  <hr>
  <button onclick="backToLive()">ðŸŸ¢ LIVE</button>
  <select id="daylist"></select>
  <button onclick="loadDay()">ðŸ“… LOAD DAY</button>
  <button onclick="chart.resetZoom()">ðŸ”„ Reset Zoom</button>
  <input type="range" id="scroll" min="0" max="100" value="100">
  <div id="modeLabel">Mode: LIVE</div>
</div>

<!-- GRAPH PANEL (bigger now) -->
<div class="panel" style="flex:4.3;">
  <h2>ðŸ“ˆ Tank Graphs</h2>
  <canvas id="chart"></canvas>
</div>

<script>
/* ===== BACKGROUND GRID ANIMATION ===== */
const bgCanvas = document.getElementById('bgCanvas');
const ctx = bgCanvas.getContext('2d');
let w = bgCanvas.width = window.innerWidth;
let h = bgCanvas.height = window.innerHeight;
const gridSpacing = 60;
let pulseOffset = 0;

window.addEventListener('resize',()=>{ w=bgCanvas.width=window.innerWidth; h=bgCanvas.height=window.innerHeight; });

function drawGrid(){
  ctx.clearRect(0,0,w,h);

  ctx.strokeStyle='rgba(0,255,255,0.15)';
  ctx.lineWidth=1;
  for(let x=0;x<=w;x+=gridSpacing){
    ctx.beginPath();
    ctx.moveTo(x+(pulseOffset%gridSpacing),0);
    ctx.lineTo(x+(pulseOffset%gridSpacing),h);
    ctx.stroke();
  }
  for(let y=0;y<=h;y+=gridSpacing){
    ctx.beginPath();
    ctx.moveTo(0,y+(pulseOffset%gridSpacing));
    ctx.lineTo(w,y+(pulseOffset%gridSpacing));
    ctx.stroke();
  }

  ctx.strokeStyle='rgba(0,255,255,0.25)';
  ctx.lineWidth=2;
  for(let i=0;i<10;i++){
    let posY = ((i*gridSpacing*2 + pulseOffset*2) % h);
    ctx.beginPath();
    ctx.moveTo(0,posY);
    ctx.lineTo(w,posY);
    ctx.stroke();
  }

  pulseOffset +=0.5;
  requestAnimationFrame(drawGrid);
}
drawGrid();

/* ===== DASHBOARD DATA & CHARTS ===== */
let chart;
let fullHistory=[];
let mode="live";
const scroll = document.getElementById("scroll");

async function fetchLive(){
  if(mode!=="live") return;
  try{
    let r = await fetch("/api/current");
    let j = await r.json();
    fullHistory = j.data || [];
    updateLatest();
    drawChart();
  }catch(e){ console.error("fetchLive failed:",e);}
}
setInterval(fetchLive,2000);

async function loadDays(){
  try{
    let r = await fetch("/api/days");
    let days = await r.json();
    daylist.innerHTML="";
    days.forEach(d=>{
      let o=document.createElement("option");
      o.value=d; o.textContent=d;
      daylist.appendChild(o);
    });
  }catch(e){console.error(e);}
}
loadDays();

async function loadDay(){
  let d = daylist.value;
  if(!d) return;
  mode="history";
  let r = await fetch("/api/history/"+d);
  fullHistory = await r.json();
  updateLatest();
  drawChart();
  modeLabel.innerText="Mode: HISTORY ("+d+")";
}
function backToLive(){
  mode="live";
  modeLabel.innerText="Mode: LIVE";
}

function updateWaterBars(){
  if(fullHistory.length===0) return;
  let l=fullHistory[fullHistory.length-1];
  if(l.p!=null) document.getElementById("tank3-fill").style.height=l.p+"%";
  if(l.up!=null) document.getElementById("tank4-fill").style.height=l.up+"%";
}
function updateLatest(){
  if(fullHistory.length===0) return;
  let l=fullHistory[fullHistory.length-1];
  v.innerText=l.v.toFixed(4);
  d.innerText=l.d.toFixed(2);
  p.innerText=l.p.toFixed(1)+"%";
  if(l.u!=null) u.innerText=l.u.toFixed(2);
  if(l.up!=null) up.innerText=l.up.toFixed(1)+"%";
  updateWaterBars();
}

function drawChart(){
  let labels = fullHistory.map(x=>new Date(x.t*1000).toLocaleTimeString());
  let volt = fullHistory.map(x=>x.v);
  let depth = fullHistory.map(x=>x.d);
  let pct = fullHistory.map(x=>x.p);
  let ultra = fullHistory.map(x=>x.u);
  let up = fullHistory.map(x=>x.up);

  let total = fullHistory.length;
  if(total>20){
    let windowSize = Math.max(Math.floor(total*0.2),20);
    let start = Math.floor((scroll.value/100)*(total-windowSize));
    labels = labels.slice(start,start+windowSize);
    volt = volt.slice(start,start+windowSize);
    depth = depth.slice(start,start+windowSize);
    pct = pct.slice(start,start+windowSize);
    ultra = ultra.slice(start,start+windowSize);
    up = up.slice(start,start+windowSize);
  }

  if(chart){
    chart.data.labels=labels;
    chart.data.datasets[0].data=volt;
    chart.data.datasets[1].data=depth;
    chart.data.datasets[2].data=pct;
    chart.data.datasets[3].data=ultra;
    chart.data.datasets[4].data=up;
    chart.update("none");
    return;
  }

  chart = new Chart(document.getElementById("chart"),{
    type:"line",
    data:{
      labels:labels,
      datasets:[
        {label:"Voltage",data:volt,borderColor:"#4ade80",borderWidth:2,pointRadius:0},
        {label:"Pressure Transducer(T3) Depth",data:depth,borderColor:"#bf730d",borderWidth:2,pointRadius:0},
        {label:"PressureTransducer(T3) %",data:pct,borderColor:"#f58c00",borderWidth:2,pointRadius:0},
        {label:"Ultrasonic(T2) Depth",data:ultra,borderColor:"#0a6ea6",borderWidth:2,pointRadius:0},
        {label:"Ultrasonic(T2) %",data:up,borderColor:"#07a3f0",borderWidth:2,pointRadius:0}
      ]
    },
    options:{
      responsive:true,
      animation:false,
      interaction:{mode:"index",intersect:false},
      plugins:{
        zoom:{
          zoom:{wheel:{enabled:true},pinch:{enabled:true},mode:"x"},
          pan:{enabled:true,mode:"x"}
        },
        tooltip:{backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#0ff",bodyColor:"#fff"}
      },
      elements:{line:{tension:0.3,borderWidth:3},point:{radius:0}},
      scales:{
        x:{ticks:{color:"#0ff"},grid:{color:"rgba(0,255,255,0.1)"}},
        y:{ticks:{color:"#0ff"},grid:{color:"rgba(0,255,255,0.1)"}}
      }
    }
  });
}

scroll.addEventListener("input",()=>{if(fullHistory.length>=20) drawChart();});
</script>
</body>
</html>
"""

@app.route("/")
def serve():
    return HTML

if __name__=="__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
